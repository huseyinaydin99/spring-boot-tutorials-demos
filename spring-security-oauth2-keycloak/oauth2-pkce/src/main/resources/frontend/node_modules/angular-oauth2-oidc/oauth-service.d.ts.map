{"version":3,"file":"oauth-service.d.ts","sources":["oauth-service.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { NgZone, OnDestroy } from '@angular/core';\r\nimport { HttpClient, HttpHeaders } from '@angular/common/http';\r\nimport { Observable, Subject, Subscription } from 'rxjs';\r\nimport { ValidationHandler, ValidationParams } from './token-validation/validation-handler';\r\nimport { UrlHelperService } from './url-helper.service';\r\nimport { OAuthEvent, OAuthSuccessEvent } from './events';\r\nimport { OAuthLogger, OAuthStorage, LoginOptions, ParsedIdToken, OidcDiscoveryDoc, TokenResponse, UserInfo } from './types';\r\nimport { AuthConfig } from './auth.config';\r\nimport { HashHandler } from './token-validation/hash-handler';\r\n/**\r\n * Service for logging in and logging out with\r\n * OIDC and OAuth2. Supports implicit flow and\r\n * password flow.\r\n */\r\nexport declare class OAuthService extends AuthConfig implements OnDestroy {\r\n    protected ngZone: NgZone;\r\n    protected http: HttpClient;\r\n    protected config: AuthConfig;\r\n    protected urlHelper: UrlHelperService;\r\n    protected logger: OAuthLogger;\r\n    protected crypto: HashHandler;\r\n    /**\r\n     * The ValidationHandler used to validate received\r\n     * id_tokens.\r\n     */\r\n    tokenValidationHandler: ValidationHandler;\r\n    /**\r\n     * @internal\r\n     * Deprecated:  use property events instead\r\n     */\r\n    discoveryDocumentLoaded: boolean;\r\n    /**\r\n     * @internal\r\n     * Deprecated:  use property events instead\r\n     */\r\n    discoveryDocumentLoaded$: Observable<OidcDiscoveryDoc>;\r\n    /**\r\n     * Informs about events, like token_received or token_expires.\r\n     * See the string enum EventType for a full list of event types.\r\n     */\r\n    events: Observable<OAuthEvent>;\r\n    /**\r\n     * The received (passed around) state, when logging\r\n     * in with implicit flow.\r\n     */\r\n    state?: string;\r\n    protected eventsSubject: Subject<OAuthEvent>;\r\n    protected discoveryDocumentLoadedSubject: Subject<OidcDiscoveryDoc>;\r\n    protected silentRefreshPostMessageEventListener: EventListener;\r\n    protected grantTypesSupported: Array<string>;\r\n    protected _storage: OAuthStorage;\r\n    protected accessTokenTimeoutSubscription: Subscription;\r\n    protected idTokenTimeoutSubscription: Subscription;\r\n    protected tokenReceivedSubscription: Subscription;\r\n    protected sessionCheckEventListener: EventListener;\r\n    protected jwksUri: string;\r\n    protected sessionCheckTimer: any;\r\n    protected silentRefreshSubject: string;\r\n    protected inImplicitFlow: boolean;\r\n    protected saveNoncesInLocalStorage: boolean;\r\n    private document;\r\n    constructor(ngZone: NgZone, http: HttpClient, storage: OAuthStorage, tokenValidationHandler: ValidationHandler, config: AuthConfig, urlHelper: UrlHelperService, logger: OAuthLogger, crypto: HashHandler, document: any);\r\n    /**\r\n     * Use this method to configure the service\r\n     * @param config the configuration\r\n     */\r\n    configure(config: AuthConfig): void;\r\n    protected configChanged(): void;\r\n    restartSessionChecksIfStillLoggedIn(): void;\r\n    protected restartRefreshTimerIfStillLoggedIn(): void;\r\n    protected setupSessionCheck(): void;\r\n    /**\r\n     * Will setup up silent refreshing for when the token is\r\n     * about to expire. When the user is logged out via this.logOut method, the\r\n     * silent refreshing will pause and not refresh the tokens until the user is\r\n     * logged back in via receiving a new token.\r\n     * @param params Additional parameter to pass\r\n     * @param listenTo Setup automatic refresh of a specific token type\r\n     */\r\n    setupAutomaticSilentRefresh(params?: object, listenTo?: 'access_token' | 'id_token' | 'any', noPrompt?: boolean): void;\r\n    protected refreshInternal(params: any, noPrompt: any): Promise<TokenResponse | OAuthEvent>;\r\n    /**\r\n     * Convenience method that first calls `loadDiscoveryDocument(...)` and\r\n     * directly chains using the `then(...)` part of the promise to call\r\n     * the `tryLogin(...)` method.\r\n     *\r\n     * @param options LoginOptions to pass through to `tryLogin(...)`\r\n     */\r\n    loadDiscoveryDocumentAndTryLogin(options?: LoginOptions): Promise<boolean>;\r\n    /**\r\n     * Convenience method that first calls `loadDiscoveryDocumentAndTryLogin(...)`\r\n     * and if then chains to `initLoginFlow()`, but only if there is no valid\r\n     * IdToken or no valid AccessToken.\r\n     *\r\n     * @param options LoginOptions to pass through to `tryLogin(...)`\r\n     */\r\n    loadDiscoveryDocumentAndLogin(options?: LoginOptions & {\r\n        state?: string;\r\n    }): Promise<boolean>;\r\n    protected debug(...args: any[]): void;\r\n    protected validateUrlFromDiscoveryDocument(url: string): string[];\r\n    protected validateUrlForHttps(url: string): boolean;\r\n    protected assertUrlNotNullAndCorrectProtocol(url: string | undefined, description: string): void;\r\n    protected validateUrlAgainstIssuer(url: string): boolean;\r\n    protected setupRefreshTimer(): void;\r\n    protected setupExpirationTimers(): void;\r\n    protected setupAccessTokenTimer(): void;\r\n    protected setupIdTokenTimer(): void;\r\n    /**\r\n     * Stops timers for automatic refresh.\r\n     * To restart it, call setupAutomaticSilentRefresh again.\r\n     */\r\n    stopAutomaticRefresh(): void;\r\n    protected clearAccessTokenTimer(): void;\r\n    protected clearIdTokenTimer(): void;\r\n    protected calcTimeout(storedAt: number, expiration: number): number;\r\n    /**\r\n     * DEPRECATED. Use a provider for OAuthStorage instead:\r\n     *\r\n     * { provide: OAuthStorage, useFactory: oAuthStorageFactory }\r\n     * export function oAuthStorageFactory(): OAuthStorage { return localStorage; }\r\n     * Sets a custom storage used to store the received\r\n     * tokens on client side. By default, the browser's\r\n     * sessionStorage is used.\r\n     * @ignore\r\n     *\r\n     * @param storage\r\n     */\r\n    setStorage(storage: OAuthStorage): void;\r\n    /**\r\n     * Loads the discovery document to configure most\r\n     * properties of this service. The url of the discovery\r\n     * document is infered from the issuer's url according\r\n     * to the OpenId Connect spec. To use another url you\r\n     * can pass it to to optional parameter fullUrl.\r\n     *\r\n     * @param fullUrl\r\n     */\r\n    loadDiscoveryDocument(fullUrl?: string): Promise<OAuthSuccessEvent>;\r\n    protected loadJwks(): Promise<object>;\r\n    protected validateDiscoveryDocument(doc: OidcDiscoveryDoc): boolean;\r\n    /**\r\n     * Uses password flow to exchange userName and password for an\r\n     * access_token. After receiving the access_token, this method\r\n     * uses it to query the userinfo endpoint in order to get information\r\n     * about the user in question.\r\n     *\r\n     * When using this, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take place that make this operation\r\n     * fail.\r\n     *\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\r\n    fetchTokenUsingPasswordFlowAndLoadUserProfile(userName: string, password: string, headers?: HttpHeaders): Promise<UserInfo>;\r\n    /**\r\n     * Loads the user profile by accessing the user info endpoint defined by OpenId Connect.\r\n     *\r\n     * When using this with OAuth2 password flow, make sure that the property oidc is set to false.\r\n     * Otherwise stricter validations take place that make this operation fail.\r\n     */\r\n    loadUserProfile(): Promise<UserInfo>;\r\n    /**\r\n     * Uses password flow to exchange userName and password for an access_token.\r\n     * @param userName\r\n     * @param password\r\n     * @param headers Optional additional http-headers.\r\n     */\r\n    fetchTokenUsingPasswordFlow(userName: string, password: string, headers?: HttpHeaders): Promise<TokenResponse>;\r\n    /**\r\n     * Refreshes the token using a refresh_token.\r\n     * This does not work for implicit flow, b/c\r\n     * there is no refresh_token in this flow.\r\n     * A solution for this is provided by the\r\n     * method silentRefresh.\r\n     */\r\n    refreshToken(): Promise<TokenResponse>;\r\n    protected removeSilentRefreshEventListener(): void;\r\n    protected setupSilentRefreshEventListener(): void;\r\n    /**\r\n     * Performs a silent refresh for implicit flow.\r\n     * Use this method to get new tokens when/before\r\n     * the existing tokens expire.\r\n     */\r\n    silentRefresh(params?: object, noPrompt?: boolean): Promise<OAuthEvent>;\r\n    /**\r\n     * This method exists for backwards compatibility.\r\n     * {@link OAuthService#initLoginFlowInPopup} handles both code\r\n     * and implicit flows.\r\n     */\r\n    initImplicitFlowInPopup(options?: {\r\n        height?: number;\r\n        width?: number;\r\n    }): Promise<unknown>;\r\n    initLoginFlowInPopup(options?: {\r\n        height?: number;\r\n        width?: number;\r\n    }): Promise<unknown>;\r\n    protected calculatePopupFeatures(options: {\r\n        height?: number;\r\n        width?: number;\r\n    }): string;\r\n    protected processMessageEventMessage(e: MessageEvent): string;\r\n    protected canPerformSessionCheck(): boolean;\r\n    protected setupSessionCheckEventListener(): void;\r\n    protected handleSessionUnchanged(): void;\r\n    protected handleSessionChange(): void;\r\n    protected waitForSilentRefreshAfterSessionChange(): void;\r\n    protected handleSessionError(): void;\r\n    protected removeSessionCheckEventListener(): void;\r\n    protected initSessionCheck(): void;\r\n    protected startSessionCheckTimer(): void;\r\n    protected stopSessionCheckTimer(): void;\r\n    checkSession(): void;\r\n    protected createLoginUrl(state?: string, loginHint?: string, customRedirectUri?: string, noPrompt?: boolean, params?: object): Promise<string>;\r\n    initImplicitFlowInternal(additionalState?: string, params?: string | object): void;\r\n    /**\r\n     * Starts the implicit flow and redirects to user to\r\n     * the auth servers' login url.\r\n     *\r\n     * @param additionalState Optional state that is passed around.\r\n     *  You'll find this state in the property `state` after `tryLogin` logged in the user.\r\n     * @param params Hash with additional parameter. If it is a string, it is used for the\r\n     *               parameter loginHint (for the sake of compatibility with former versions)\r\n     */\r\n    initImplicitFlow(additionalState?: string, params?: string | object): void;\r\n    /**\r\n     * Reset current implicit flow\r\n     *\r\n     * @description This method allows resetting the current implict flow in order to be initialized again.\r\n     */\r\n    resetImplicitFlow(): void;\r\n    protected callOnTokenReceivedIfExists(options: LoginOptions): void;\r\n    protected storeAccessTokenResponse(accessToken: string, refreshToken: string, expiresIn: number, grantedScopes: String, customParameters?: Map<string, string>): void;\r\n    /**\r\n     * Delegates to tryLoginImplicitFlow for the sake of competability\r\n     * @param options Optional options.\r\n     */\r\n    tryLogin(options?: LoginOptions): Promise<boolean>;\r\n    private parseQueryString;\r\n    tryLoginCodeFlow(options?: LoginOptions): Promise<void>;\r\n    /**\r\n     * Retrieve the returned auth code from the redirect uri that has been called.\r\n     * If required also check hash, as we could use hash location strategy.\r\n     */\r\n    private getCodePartsFromUrl;\r\n    /**\r\n     * Get token using an intermediate code. Works for the Authorization Code flow.\r\n     */\r\n    private getTokenFromCode;\r\n    private fetchAndProcessToken;\r\n    /**\r\n     * Checks whether there are tokens in the hash fragment\r\n     * as a result of the implicit flow. These tokens are\r\n     * parsed, validated and used to sign the user in to the\r\n     * current client.\r\n     *\r\n     * @param options Optional options.\r\n     */\r\n    tryLoginImplicitFlow(options?: LoginOptions): Promise<boolean>;\r\n    private parseState;\r\n    protected validateNonce(nonceInState: string): boolean;\r\n    protected storeIdToken(idToken: ParsedIdToken): void;\r\n    protected storeSessionState(sessionState: string): void;\r\n    protected getSessionState(): string;\r\n    protected handleLoginError(options: LoginOptions, parts: object): void;\r\n    /**\r\n     * @ignore\r\n     */\r\n    processIdToken(idToken: string, accessToken: string, skipNonceCheck?: boolean): Promise<ParsedIdToken>;\r\n    /**\r\n     * Returns the received claims about the user.\r\n     */\r\n    getIdentityClaims(): object;\r\n    /**\r\n     * Returns the granted scopes from the server.\r\n     */\r\n    getGrantedScopes(): object;\r\n    /**\r\n     * Returns the current id_token.\r\n     */\r\n    getIdToken(): string;\r\n    protected padBase64(base64data: any): string;\r\n    /**\r\n     * Returns the current access_token.\r\n     */\r\n    getAccessToken(): string;\r\n    getRefreshToken(): string;\r\n    /**\r\n     * Returns the expiration date of the access_token\r\n     * as milliseconds since 1970.\r\n     */\r\n    getAccessTokenExpiration(): number;\r\n    protected getAccessTokenStoredAt(): number;\r\n    protected getIdTokenStoredAt(): number;\r\n    /**\r\n     * Returns the expiration date of the id_token\r\n     * as milliseconds since 1970.\r\n     */\r\n    getIdTokenExpiration(): number;\r\n    /**\r\n     * Checkes, whether there is a valid access_token.\r\n     */\r\n    hasValidAccessToken(): boolean;\r\n    /**\r\n     * Checks whether there is a valid id_token.\r\n     */\r\n    hasValidIdToken(): boolean;\r\n    /**\r\n     * Retrieve a saved custom property of the TokenReponse object. Only if predefined in authconfig.\r\n     */\r\n    getCustomTokenResponseProperty(requestedProperty: string): any;\r\n    /**\r\n     * Returns the auth-header that can be used\r\n     * to transmit the access_token to a service\r\n     */\r\n    authorizationHeader(): string;\r\n    /**\r\n     * Removes all tokens and logs the user out.\r\n     * If a logout url is configured, the user is\r\n     * redirected to it with optional state parameter.\r\n     * @param noRedirectToLogoutUrl\r\n     * @param state\r\n     */\r\n    logOut(): void;\r\n    logOut(customParameters: object): void;\r\n    logOut(noRedirectToLogoutUrl: boolean): void;\r\n    logOut(noRedirectToLogoutUrl: boolean, state: string): void;\r\n    /**\r\n     * @ignore\r\n     */\r\n    createAndSaveNonce(): Promise<string>;\r\n    /**\r\n     * @ignore\r\n     */\r\n    ngOnDestroy(): void;\r\n    protected createNonce(): Promise<string>;\r\n    protected checkAtHash(params: ValidationParams): Promise<boolean>;\r\n    protected checkSignature(params: ValidationParams): Promise<any>;\r\n    /**\r\n     * Start the implicit flow or the code flow,\r\n     * depending on your configuration.\r\n     */\r\n    initLoginFlow(additionalState?: string, params?: {}): void;\r\n    /**\r\n     * Starts the authorization code flow and redirects to user to\r\n     * the auth servers login url.\r\n     */\r\n    initCodeFlow(additionalState?: string, params?: {}): void;\r\n    private initCodeFlowInternal;\r\n    protected createChallangeVerifierPairForPKCE(): Promise<[string, string]>;\r\n    private extractRecognizedCustomParameters;\r\n    /**\r\n     * Revokes the auth token to secure the vulnarability\r\n     * of the token issued allowing the authorization server to clean\r\n     * up any security credentials associated with the authorization\r\n     */\r\n    revokeTokenAndLogout(customParameters?: object, ignoreCorsIssues?: boolean): Promise<any>;\r\n}\r\n"]}